import {
  require_react_dom
} from "./chunk-QJV3R4PZ.js";
import {
  require_react
} from "./chunk-JFTBQ7A7.js";
import {
  __commonJS
} from "./chunk-AC2VUBZ6.js";

// node_modules/react-animated-numbers/dist/index.js
var require_dist = __commonJS({
  "node_modules/react-animated-numbers/dist/index.js"(exports, module) {
    !function(e, t) {
      if ("object" == typeof exports && "object" == typeof module)
        module.exports = t(require_react(), require_react_dom());
      else if ("function" == typeof define && define.amd)
        define(["react", "react-dom"], t);
      else {
        var n = "object" == typeof exports ? t(require_react(), require_react_dom()) : t(e.react, e["react-dom"]);
        for (var s in n)
          ("object" == typeof exports ? exports : e)[s] = n[s];
      }
    }(self, function(e, t) {
      return (() => {
        "use strict";
        var n = { 297: (t2) => {
          t2.exports = e;
        }, 268: (e2) => {
          e2.exports = t;
        } }, s = {};
        function r(e2) {
          var t2 = s[e2];
          if (void 0 !== t2)
            return t2.exports;
          var i2 = s[e2] = { exports: {} };
          return n[e2](i2, i2.exports, r), i2.exports;
        }
        r.n = (e2) => {
          var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
          return r.d(t2, { a: t2 }), t2;
        }, r.d = (e2, t2) => {
          for (var n2 in t2)
            r.o(t2, n2) && !r.o(e2, n2) && Object.defineProperty(e2, n2, { enumerable: true, get: t2[n2] });
        }, r.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r.r = (e2) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        };
        var i = {};
        return (() => {
          r.r(i), r.d(i, { default: () => es });
          var e2 = r(297), t2 = r.n(e2);
          let n2 = _();
          const s2 = (e3) => g(e3, n2);
          let o = _();
          s2.write = (e3) => g(e3, o);
          let a = _();
          s2.onStart = (e3) => g(e3, a);
          let u = _();
          s2.onFrame = (e3) => g(e3, u);
          let l = _();
          s2.onFinish = (e3) => g(e3, l);
          let c = [];
          s2.setTimeout = (e3, t3) => {
            let n3 = s2.now() + t3, r2 = () => {
              let e4 = c.findIndex((e5) => e5.cancel == r2);
              ~e4 && c.splice(e4, 1), f -= ~e4 ? 1 : 0;
            }, i2 = { time: n3, handler: e3, cancel: r2 };
            return c.splice(d(n3), 0, i2), f += 1, y(), i2;
          };
          let d = (e3) => ~(~c.findIndex((t3) => t3.time > e3) || ~c.length);
          s2.cancel = (e3) => {
            a.delete(e3), u.delete(e3), n2.delete(e3), o.delete(e3), l.delete(e3);
          }, s2.sync = (e3) => {
            m = true, s2.batchedUpdates(e3), m = false;
          }, s2.throttle = (e3) => {
            let t3;
            function n3() {
              try {
                e3(...t3);
              } finally {
                t3 = null;
              }
            }
            function r2(...e4) {
              t3 = e4, s2.onStart(n3);
            }
            return r2.handler = e3, r2.cancel = () => {
              a.delete(n3), t3 = null;
            }, r2;
          };
          let h = "undefined" != typeof window ? window.requestAnimationFrame : () => {
          };
          s2.use = (e3) => h = e3, s2.now = "undefined" != typeof performance ? () => performance.now() : Date.now, s2.batchedUpdates = (e3) => e3(), s2.catch = console.error, s2.frameLoop = "always", s2.advance = () => {
            "demand" !== s2.frameLoop ? console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand") : b();
          };
          let p = -1, f = 0, m = false;
          function g(e3, t3) {
            m ? (t3.delete(e3), e3(0)) : (t3.add(e3), y());
          }
          function y() {
            p < 0 && (p = 0, "demand" !== s2.frameLoop && h(v));
          }
          function v() {
            ~p && (h(v), s2.batchedUpdates(b));
          }
          function b() {
            let e3 = p;
            p = s2.now();
            let t3 = d(p);
            t3 && (w(c.splice(0, t3), (e4) => e4.handler()), f -= t3), a.flush(), n2.flush(e3 ? Math.min(64, p - e3) : 16.667), u.flush(), o.flush(), l.flush(), f || (p = -1);
          }
          function _() {
            let e3 = /* @__PURE__ */ new Set(), t3 = e3;
            return { add(n3) {
              f += t3 != e3 || e3.has(n3) ? 0 : 1, e3.add(n3);
            }, delete: (n3) => (f -= t3 == e3 && e3.has(n3) ? 1 : 0, e3.delete(n3)), flush(n3) {
              t3.size && (e3 = /* @__PURE__ */ new Set(), f -= t3.size, w(t3, (t4) => t4(n3) && e3.add(t4)), f += e3.size, t3 = e3);
            } };
          }
          function w(e3, t3) {
            e3.forEach((e4) => {
              try {
                t3(e4);
              } catch (e5) {
                s2.catch(e5);
              }
            });
          }
          function k() {
          }
          const P = { arr: Array.isArray, obj: (e3) => !!e3 && "Object" === e3.constructor.name, fun: (e3) => "function" == typeof e3, str: (e3) => "string" == typeof e3, num: (e3) => "number" == typeof e3, und: (e3) => void 0 === e3 };
          function S(e3, t3) {
            if (P.arr(e3)) {
              if (!P.arr(t3) || e3.length !== t3.length)
                return false;
              for (let n3 = 0; n3 < e3.length; n3++)
                if (e3[n3] !== t3[n3])
                  return false;
              return true;
            }
            return e3 === t3;
          }
          const x = (e3, t3) => e3.forEach(t3);
          function V(e3, t3, n3) {
            if (P.arr(e3))
              for (let s3 = 0; s3 < e3.length; s3++)
                t3.call(n3, e3[s3], `${s3}`);
            else
              for (const s3 in e3)
                e3.hasOwnProperty(s3) && t3.call(n3, e3[s3], s3);
          }
          const O = (e3) => P.und(e3) ? [] : P.arr(e3) ? e3 : [e3];
          function C(e3, t3) {
            if (e3.size) {
              const n3 = Array.from(e3);
              e3.clear(), x(n3, t3);
            }
          }
          const A = (e3, ...t3) => C(e3, (e4) => e4(...t3)), I = () => "undefined" == typeof window || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
          let j, R, M = null, E = false, q = k;
          var N = Object.freeze({ __proto__: null, get createStringInterpolator() {
            return j;
          }, get to() {
            return R;
          }, get colors() {
            return M;
          }, get skipAnimation() {
            return E;
          }, get willAdvance() {
            return q;
          }, assign: (e3) => {
            e3.to && (R = e3.to), e3.now && (s2.now = e3.now), void 0 !== e3.colors && (M = e3.colors), null != e3.skipAnimation && (E = e3.skipAnimation), e3.createStringInterpolator && (j = e3.createStringInterpolator), e3.requestAnimationFrame && s2.use(e3.requestAnimationFrame), e3.batchedUpdates && (s2.batchedUpdates = e3.batchedUpdates), e3.willAdvance && (q = e3.willAdvance), e3.frameLoop && (s2.frameLoop = e3.frameLoop);
          } });
          const T = /* @__PURE__ */ new Set();
          let z = [], $ = [], F = 0;
          const U = { get idle() {
            return !T.size && !z.length;
          }, start(e3) {
            F > e3.priority ? (T.add(e3), s2.onStart(D)) : (L(e3), s2(W));
          }, advance: W, sort(e3) {
            if (F)
              s2.onFrame(() => U.sort(e3));
            else {
              const t3 = z.indexOf(e3);
              ~t3 && (z.splice(t3, 1), Q(e3));
            }
          }, clear() {
            z = [], T.clear();
          } };
          function D() {
            T.forEach(L), T.clear(), s2(W);
          }
          function L(e3) {
            z.includes(e3) || Q(e3);
          }
          function Q(e3) {
            z.splice(function(t3, n3) {
              const s3 = t3.findIndex((t4) => t4.priority > e3.priority);
              return s3 < 0 ? t3.length : s3;
            }(z), 0, e3);
          }
          function W(e3) {
            const t3 = $;
            for (let n3 = 0; n3 < z.length; n3++) {
              const s3 = z[n3];
              F = s3.priority, s3.idle || (q(s3), s3.advance(e3), s3.idle || t3.push(s3));
            }
            return F = 0, $ = z, $.length = 0, z = t3, z.length > 0;
          }
          const G = "[-+]?\\d*\\.?\\d+", B = G + "%";
          function Y(...e3) {
            return "\\(\\s*(" + e3.join(")\\s*,\\s*(") + ")\\s*\\)";
          }
          const Z = new RegExp("rgb" + Y(G, G, G)), H = new RegExp("rgba" + Y(G, G, G, G)), J = new RegExp("hsl" + Y(G, B, B)), X = new RegExp("hsla" + Y(G, B, B, G)), K = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, ee = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, te = /^#([0-9a-fA-F]{6})$/, ne = /^#([0-9a-fA-F]{8})$/;
          function se(e3, t3, n3) {
            return n3 < 0 && (n3 += 1), n3 > 1 && (n3 -= 1), n3 < 1 / 6 ? e3 + 6 * (t3 - e3) * n3 : n3 < 0.5 ? t3 : n3 < 2 / 3 ? e3 + (t3 - e3) * (2 / 3 - n3) * 6 : e3;
          }
          function re(e3, t3, n3) {
            const s3 = n3 < 0.5 ? n3 * (1 + t3) : n3 + t3 - n3 * t3, r2 = 2 * n3 - s3, i2 = se(r2, s3, e3 + 1 / 3), o2 = se(r2, s3, e3), a2 = se(r2, s3, e3 - 1 / 3);
            return Math.round(255 * i2) << 24 | Math.round(255 * o2) << 16 | Math.round(255 * a2) << 8;
          }
          function ie(e3) {
            const t3 = parseInt(e3, 10);
            return t3 < 0 ? 0 : t3 > 255 ? 255 : t3;
          }
          function oe(e3) {
            return (parseFloat(e3) % 360 + 360) % 360 / 360;
          }
          function ae(e3) {
            const t3 = parseFloat(e3);
            return t3 < 0 ? 0 : t3 > 1 ? 255 : Math.round(255 * t3);
          }
          function ue(e3) {
            const t3 = parseFloat(e3);
            return t3 < 0 ? 0 : t3 > 100 ? 1 : t3 / 100;
          }
          function le(e3) {
            let t3 = function(e4) {
              let t4;
              return "number" == typeof e4 ? e4 >>> 0 === e4 && e4 >= 0 && e4 <= 4294967295 ? e4 : null : (t4 = te.exec(e4)) ? parseInt(t4[1] + "ff", 16) >>> 0 : M && void 0 !== M[e4] ? M[e4] : (t4 = Z.exec(e4)) ? (ie(t4[1]) << 24 | ie(t4[2]) << 16 | ie(t4[3]) << 8 | 255) >>> 0 : (t4 = H.exec(e4)) ? (ie(t4[1]) << 24 | ie(t4[2]) << 16 | ie(t4[3]) << 8 | ae(t4[4])) >>> 0 : (t4 = K.exec(e4)) ? parseInt(t4[1] + t4[1] + t4[2] + t4[2] + t4[3] + t4[3] + "ff", 16) >>> 0 : (t4 = ne.exec(e4)) ? parseInt(t4[1], 16) >>> 0 : (t4 = ee.exec(e4)) ? parseInt(t4[1] + t4[1] + t4[2] + t4[2] + t4[3] + t4[3] + t4[4] + t4[4], 16) >>> 0 : (t4 = J.exec(e4)) ? (255 | re(oe(t4[1]), ue(t4[2]), ue(t4[3]))) >>> 0 : (t4 = X.exec(e4)) ? (re(oe(t4[1]), ue(t4[2]), ue(t4[3])) | ae(t4[4])) >>> 0 : null;
            }(e3);
            return null === t3 ? e3 : (t3 = t3 || 0, `rgba(${(4278190080 & t3) >>> 24}, ${(16711680 & t3) >>> 16}, ${(65280 & t3) >>> 8}, ${(255 & t3) / 255})`);
          }
          const ce = (e3, t3, n3) => {
            if (P.fun(e3))
              return e3;
            if (P.arr(e3))
              return ce({ range: e3, output: t3, extrapolate: n3 });
            if (P.str(e3.output[0]))
              return j(e3);
            const s3 = e3, r2 = s3.output, i2 = s3.range || [0, 1], o2 = s3.extrapolateLeft || s3.extrapolate || "extend", a2 = s3.extrapolateRight || s3.extrapolate || "extend", u2 = s3.easing || ((e4) => e4);
            return (e4) => {
              const t4 = function(e5, t5) {
                for (var n4 = 1; n4 < t5.length - 1 && !(t5[n4] >= e5); ++n4)
                  ;
                return n4 - 1;
              }(e4, i2);
              return function(e5, t5, n4, s4, r3, i3, o3, a3, u3) {
                let l2 = u3 ? u3(e5) : e5;
                if (l2 < t5) {
                  if ("identity" === o3)
                    return l2;
                  "clamp" === o3 && (l2 = t5);
                }
                if (l2 > n4) {
                  if ("identity" === a3)
                    return l2;
                  "clamp" === a3 && (l2 = n4);
                }
                return s4 === r3 ? s4 : t5 === n4 ? e5 <= t5 ? s4 : r3 : (t5 === -1 / 0 ? l2 = -l2 : n4 === 1 / 0 ? l2 -= t5 : l2 = (l2 - t5) / (n4 - t5), l2 = i3(l2), s4 === -1 / 0 ? l2 = -l2 : r3 === 1 / 0 ? l2 += s4 : l2 = l2 * (r3 - s4) + s4, l2);
              }(e4, i2[t4], i2[t4 + 1], r2[t4], r2[t4 + 1], u2, o2, a2, s3.map);
            };
          };
          function de() {
            return (de = Object.assign || function(e3) {
              for (var t3 = 1; t3 < arguments.length; t3++) {
                var n3 = arguments[t3];
                for (var s3 in n3)
                  Object.prototype.hasOwnProperty.call(n3, s3) && (e3[s3] = n3[s3]);
              }
              return e3;
            }).apply(this, arguments);
          }
          const he = Symbol.for("FluidValue.get"), pe = Symbol.for("FluidValue.observers"), fe = (e3) => Boolean(e3 && e3[he]), me = (e3) => e3 && e3[he] ? e3[he]() : e3, ge = (e3) => e3[pe] || null;
          function ye(e3, t3) {
            let n3 = e3[pe];
            n3 && n3.forEach((e4) => {
              !function(e5, t4) {
                e5.eventObserved ? e5.eventObserved(t4) : e5(t4);
              }(e4, t3);
            });
          }
          class ve {
            constructor(e3) {
              if (this[he] = void 0, this[pe] = void 0, !e3 && !(e3 = this.get))
                throw Error("Unknown getter");
              be(this, e3);
            }
          }
          const be = (e3, t3) => ke(e3, he, t3);
          function _e(e3, t3) {
            if (e3[he]) {
              let n3 = e3[pe];
              n3 || ke(e3, pe, n3 = /* @__PURE__ */ new Set()), n3.has(t3) || (n3.add(t3), e3.observerAdded && e3.observerAdded(n3.size, t3));
            }
            return t3;
          }
          function we(e3, t3) {
            let n3 = e3[pe];
            if (n3 && n3.has(t3)) {
              const s3 = n3.size - 1;
              s3 ? n3.delete(t3) : e3[pe] = null, e3.observerRemoved && e3.observerRemoved(s3, t3);
            }
          }
          const ke = (e3, t3, n3) => Object.defineProperty(e3, t3, { value: n3, writable: true, configurable: true }), Pe = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, Se = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi, xe = new RegExp(`(${Pe.source})(%|[a-z]+)`, "i"), Ve = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, Oe = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/, Ce = (e3) => {
            const [t3, n3] = Ae(e3);
            if (!t3 || I())
              return e3;
            const s3 = window.getComputedStyle(document.documentElement).getPropertyValue(t3);
            if (s3)
              return s3.trim();
            if (n3 && n3.startsWith("--")) {
              return window.getComputedStyle(document.documentElement).getPropertyValue(n3) || e3;
            }
            return n3 && Oe.test(n3) ? Ce(n3) : n3 || e3;
          }, Ae = (e3) => {
            const t3 = Oe.exec(e3);
            if (!t3)
              return [,];
            const [, n3, s3] = t3;
            return [n3, s3];
          };
          let Ie;
          const je = (e3, t3, n3, s3, r2) => `rgba(${Math.round(t3)}, ${Math.round(n3)}, ${Math.round(s3)}, ${r2})`, Re = (e3) => {
            Ie || (Ie = M ? new RegExp(`(${Object.keys(M).join("|")})(?!\\w)`, "g") : /^\b$/);
            const t3 = e3.output.map((e4) => me(e4).replace(Oe, Ce).replace(Se, le).replace(Ie, le)), n3 = t3.map((e4) => e4.match(Pe).map(Number)), s3 = n3[0].map((e4, t4) => n3.map((e5) => {
              if (!(t4 in e5))
                throw Error('The arity of each "output" value must be equal');
              return e5[t4];
            })).map((t4) => ce(de({}, e3, { output: t4 })));
            return (e4) => {
              var n4;
              const r2 = !xe.test(t3[0]) && (null == (n4 = t3.find((e5) => xe.test(e5))) ? void 0 : n4.replace(Pe, ""));
              let i2 = 0;
              return t3[0].replace(Pe, () => `${s3[i2++](e4)}${r2 || ""}`).replace(Ve, je);
            };
          }, Me = "react-spring: ", Ee = (e3) => {
            const t3 = e3;
            let n3 = false;
            if ("function" != typeof t3)
              throw new TypeError(`${Me}once requires a function parameter`);
            return (...e4) => {
              n3 || (t3(...e4), n3 = true);
            };
          }, qe = Ee(console.warn), Ne = Ee(console.warn);
          function Te(e3) {
            return P.str(e3) && ("#" == e3[0] || /\d/.test(e3) || !I() && Oe.test(e3) || e3 in (M || {}));
          }
          const ze = "undefined" != typeof window && window.document && window.document.createElement ? e2.useLayoutEffect : e2.useEffect;
          function $e() {
            const t3 = (0, e2.useState)()[1], n3 = (() => {
              const t4 = (0, e2.useRef)(false);
              return ze(() => (t4.current = true, () => {
                t4.current = false;
              }), []), t4;
            })();
            return () => {
              n3.current && t3(Math.random());
            };
          }
          const Fe = (t3) => (0, e2.useEffect)(t3, Ue), Ue = [];
          function De(t3) {
            const n3 = (0, e2.useRef)();
            return (0, e2.useEffect)(() => {
              n3.current = t3;
            }), n3.current;
          }
          const Le = Symbol.for("Animated:node"), Qe = (e3) => e3 && e3[Le], We = (e3, t3) => {
            return n3 = e3, s3 = Le, r2 = t3, Object.defineProperty(n3, s3, { value: r2, writable: true, configurable: true });
            var n3, s3, r2;
          }, Ge = (e3) => e3 && e3[Le] && e3[Le].getPayload();
          class Be {
            constructor() {
              this.payload = void 0, We(this, this);
            }
            getPayload() {
              return this.payload || [];
            }
          }
          class Ye extends Be {
            constructor(e3) {
              super(), this.done = true, this.elapsedTime = void 0, this.lastPosition = void 0, this.lastVelocity = void 0, this.v0 = void 0, this.durationProgress = 0, this._value = e3, P.num(this._value) && (this.lastPosition = this._value);
            }
            static create(e3) {
              return new Ye(e3);
            }
            getPayload() {
              return [this];
            }
            getValue() {
              return this._value;
            }
            setValue(e3, t3) {
              return P.num(e3) && (this.lastPosition = e3, t3 && (e3 = Math.round(e3 / t3) * t3, this.done && (this.lastPosition = e3))), this._value !== e3 && (this._value = e3, true);
            }
            reset() {
              const { done: e3 } = this;
              this.done = false, P.num(this._value) && (this.elapsedTime = 0, this.durationProgress = 0, this.lastPosition = this._value, e3 && (this.lastVelocity = null), this.v0 = null);
            }
          }
          class Ze extends Ye {
            constructor(e3) {
              super(0), this._string = null, this._toString = void 0, this._toString = ce({ output: [e3, e3] });
            }
            static create(e3) {
              return new Ze(e3);
            }
            getValue() {
              let e3 = this._string;
              return null == e3 ? this._string = this._toString(this._value) : e3;
            }
            setValue(e3) {
              if (P.str(e3)) {
                if (e3 == this._string)
                  return false;
                this._string = e3, this._value = 1;
              } else {
                if (!super.setValue(e3))
                  return false;
                this._string = null;
              }
              return true;
            }
            reset(e3) {
              e3 && (this._toString = ce({ output: [this.getValue(), e3] })), this._value = 0, super.reset();
            }
          }
          const He = { dependencies: null };
          class Je extends Be {
            constructor(e3) {
              super(), this.source = e3, this.setValue(e3);
            }
            getValue(e3) {
              const t3 = {};
              return V(this.source, (n3, s3) => {
                var r2;
                (r2 = n3) && r2[Le] === r2 ? t3[s3] = n3.getValue(e3) : fe(n3) ? t3[s3] = me(n3) : e3 || (t3[s3] = n3);
              }), t3;
            }
            setValue(e3) {
              this.source = e3, this.payload = this._makePayload(e3);
            }
            reset() {
              this.payload && x(this.payload, (e3) => e3.reset());
            }
            _makePayload(e3) {
              if (e3) {
                const t3 = /* @__PURE__ */ new Set();
                return V(e3, this._addToPayload, t3), Array.from(t3);
              }
            }
            _addToPayload(e3) {
              He.dependencies && fe(e3) && He.dependencies.add(e3);
              const t3 = Ge(e3);
              t3 && x(t3, (e4) => this.add(e4));
            }
          }
          class Xe extends Je {
            constructor(e3) {
              super(e3);
            }
            static create(e3) {
              return new Xe(e3);
            }
            getValue() {
              return this.source.map((e3) => e3.getValue());
            }
            setValue(e3) {
              const t3 = this.getPayload();
              return e3.length == t3.length ? t3.map((t4, n3) => t4.setValue(e3[n3])).some(Boolean) : (super.setValue(e3.map(Ke)), true);
            }
          }
          function Ke(e3) {
            return (Te(e3) ? Ze : Ye).create(e3);
          }
          function et(e3) {
            const t3 = Qe(e3);
            return t3 ? t3.constructor : P.arr(e3) ? Xe : Te(e3) ? Ze : Ye;
          }
          function tt() {
            return (tt = Object.assign || function(e3) {
              for (var t3 = 1; t3 < arguments.length; t3++) {
                var n3 = arguments[t3];
                for (var s3 in n3)
                  Object.prototype.hasOwnProperty.call(n3, s3) && (e3[s3] = n3[s3]);
              }
              return e3;
            }).apply(this, arguments);
          }
          const nt = (t3, n3) => {
            const r2 = !P.fun(t3) || t3.prototype && t3.prototype.isReactComponent;
            return (0, e2.forwardRef)((i2, o2) => {
              const a2 = (0, e2.useRef)(null), u2 = r2 && (0, e2.useCallback)((e3) => {
                a2.current = function(e4, t4) {
                  return e4 && (P.fun(e4) ? e4(t4) : e4.current = t4), t4;
                }(o2, e3);
              }, [o2]), [l2, c2] = function(e3, t4) {
                const n4 = /* @__PURE__ */ new Set();
                return He.dependencies = n4, e3.style && (e3 = tt({}, e3, { style: t4.createAnimatedStyle(e3.style) })), e3 = new Je(e3), He.dependencies = null, [e3, n4];
              }(i2, n3), d2 = $e(), h2 = () => {
                const e3 = a2.current;
                r2 && !e3 || false === (!!e3 && n3.applyAnimatedValues(e3, l2.getValue(true))) && d2();
              }, p2 = new st(h2, c2), f2 = (0, e2.useRef)();
              ze(() => (f2.current = p2, x(c2, (e3) => _e(e3, p2)), () => {
                f2.current && (x(f2.current.deps, (e3) => we(e3, f2.current)), s2.cancel(f2.current.update));
              })), (0, e2.useEffect)(h2, []), Fe(() => () => {
                const e3 = f2.current;
                x(e3.deps, (t4) => we(t4, e3));
              });
              const m2 = n3.getComponentProps(l2.getValue());
              return e2.createElement(t3, tt({}, m2, { ref: u2 }));
            });
          };
          class st {
            constructor(e3, t3) {
              this.update = e3, this.deps = t3;
            }
            eventObserved(e3) {
              "change" == e3.type && s2.write(this.update);
            }
          }
          const rt = Symbol.for("AnimatedComponent"), it = (e3) => P.str(e3) ? e3 : e3 && P.str(e3.displayName) ? e3.displayName : P.fun(e3) && e3.name || null;
          function ot() {
            return (ot = Object.assign || function(e3) {
              for (var t3 = 1; t3 < arguments.length; t3++) {
                var n3 = arguments[t3];
                for (var s3 in n3)
                  Object.prototype.hasOwnProperty.call(n3, s3) && (e3[s3] = n3[s3]);
              }
              return e3;
            }).apply(this, arguments);
          }
          function at(e3, ...t3) {
            return P.fun(e3) ? e3(...t3) : e3;
          }
          const ut = (e3, t3) => true === e3 || !!(t3 && e3 && (P.fun(e3) ? e3(t3) : O(e3).includes(t3))), lt = (e3, t3) => P.obj(e3) ? t3 && e3[t3] : e3, ct = (e3, t3) => true === e3.default ? e3[t3] : e3.default ? e3.default[t3] : void 0, dt = (e3) => e3, ht = (e3, t3 = dt) => {
            let n3 = pt;
            e3.default && true !== e3.default && (e3 = e3.default, n3 = Object.keys(e3));
            const s3 = {};
            for (const r2 of n3) {
              const n4 = t3(e3[r2], r2);
              P.und(n4) || (s3[r2] = n4);
            }
            return s3;
          }, pt = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"], ft = { config: 1, from: 1, to: 1, ref: 1, loop: 1, reset: 1, pause: 1, cancel: 1, reverse: 1, immediate: 1, default: 1, delay: 1, onProps: 1, onStart: 1, onChange: 1, onPause: 1, onResume: 1, onRest: 1, onResolve: 1, items: 1, trail: 1, sort: 1, expires: 1, initial: 1, enter: 1, update: 1, leave: 1, children: 1, onDestroyed: 1, keys: 1, callId: 1, parentId: 1 };
          function mt(e3) {
            const t3 = function(e4) {
              const t4 = {};
              let n3 = 0;
              if (V(e4, (e5, s3) => {
                ft[s3] || (t4[s3] = e5, n3++);
              }), n3)
                return t4;
            }(e3);
            if (t3) {
              const n3 = { to: t3 };
              return V(e3, (e4, s3) => s3 in t3 || (n3[s3] = e4)), n3;
            }
            return ot({}, e3);
          }
          function gt(e3) {
            return e3 = me(e3), P.arr(e3) ? e3.map(gt) : Te(e3) ? N.createStringInterpolator({ range: [0, 1], output: [e3, e3] })(1) : e3;
          }
          function yt(e3) {
            for (const t3 in e3)
              return true;
            return false;
          }
          function vt(e3) {
            return P.fun(e3) || P.arr(e3) && P.obj(e3[0]);
          }
          function bt(e3, t3) {
            var n3;
            null == (n3 = e3.ref) || n3.delete(e3), null == t3 || t3.delete(e3);
          }
          function _t(e3, t3) {
            var n3;
            t3 && e3.ref !== t3 && (null == (n3 = e3.ref) || n3.delete(e3), t3.add(e3), e3.ref = t3);
          }
          Math.PI, Math.PI;
          const wt = ot({}, { tension: 170, friction: 26 }, { mass: 1, damping: 1, easing: (e3) => e3, clamp: false });
          class kt {
            constructor() {
              this.tension = void 0, this.friction = void 0, this.frequency = void 0, this.damping = void 0, this.mass = void 0, this.velocity = 0, this.restVelocity = void 0, this.precision = void 0, this.progress = void 0, this.duration = void 0, this.easing = void 0, this.clamp = void 0, this.bounce = void 0, this.decay = void 0, this.round = void 0, Object.assign(this, wt);
            }
          }
          function Pt(e3, t3) {
            if (P.und(t3.decay)) {
              const n3 = !P.und(t3.tension) || !P.und(t3.friction);
              !n3 && P.und(t3.frequency) && P.und(t3.damping) && P.und(t3.mass) || (e3.duration = void 0, e3.decay = void 0), n3 && (e3.frequency = void 0);
            } else
              e3.duration = void 0;
          }
          const St = [];
          class xt {
            constructor() {
              this.changed = false, this.values = St, this.toValues = null, this.fromValues = St, this.to = void 0, this.from = void 0, this.config = new kt(), this.immediate = false;
            }
          }
          function Vt(e3, { key: t3, props: n3, defaultProps: r2, state: i2, actions: o2 }) {
            return new Promise((a2, u2) => {
              var l2;
              let c2, d2, h2 = ut(null != (l2 = n3.cancel) ? l2 : null == r2 ? void 0 : r2.cancel, t3);
              if (h2)
                m2();
              else {
                P.und(n3.pause) || (i2.paused = ut(n3.pause, t3));
                let e4 = null == r2 ? void 0 : r2.pause;
                true !== e4 && (e4 = i2.paused || ut(e4, t3)), c2 = at(n3.delay || 0, t3), e4 ? (i2.resumeQueue.add(f2), o2.pause()) : (o2.resume(), f2());
              }
              function p2() {
                i2.resumeQueue.add(f2), i2.timeouts.delete(d2), d2.cancel(), c2 = d2.time - s2.now();
              }
              function f2() {
                c2 > 0 && !N.skipAnimation ? (i2.delayed = true, d2 = s2.setTimeout(m2, c2), i2.pauseQueue.add(p2), i2.timeouts.add(d2)) : m2();
              }
              function m2() {
                i2.delayed && (i2.delayed = false), i2.pauseQueue.delete(p2), i2.timeouts.delete(d2), e3 <= (i2.cancelId || 0) && (h2 = true);
                try {
                  o2.start(ot({}, n3, { callId: e3, cancel: h2 }), a2);
                } catch (e4) {
                  u2(e4);
                }
              }
            });
          }
          const Ot = (e3, t3) => 1 == t3.length ? t3[0] : t3.some((e4) => e4.cancelled) ? It(e3.get()) : t3.every((e4) => e4.noop) ? Ct(e3.get()) : At(e3.get(), t3.every((e4) => e4.finished)), Ct = (e3) => ({ value: e3, noop: true, finished: true, cancelled: false }), At = (e3, t3, n3 = false) => ({ value: e3, finished: t3, cancelled: n3 }), It = (e3) => ({ value: e3, cancelled: true, finished: false });
          function jt(e3, t3, n3, r2) {
            const { callId: i2, parentId: o2, onRest: a2 } = t3, { asyncTo: u2, promise: l2 } = n3;
            return o2 || e3 !== u2 || t3.reset ? n3.promise = (async () => {
              n3.asyncId = i2, n3.asyncTo = e3;
              const c2 = ht(t3, (e4, t4) => "onRest" === t4 ? void 0 : e4);
              let d2, h2;
              const p2 = new Promise((e4, t4) => (d2 = e4, h2 = t4)), f2 = (e4) => {
                const t4 = i2 <= (n3.cancelId || 0) && It(r2) || i2 !== n3.asyncId && At(r2, false);
                if (t4)
                  throw e4.result = t4, h2(e4), e4;
              }, m2 = (e4, t4) => {
                const s3 = new Mt(), o3 = new Et();
                return (async () => {
                  if (N.skipAnimation)
                    throw Rt(n3), o3.result = At(r2, false), h2(o3), o3;
                  f2(s3);
                  const a3 = P.obj(e4) ? ot({}, e4) : ot({}, t4, { to: e4 });
                  a3.parentId = i2, V(c2, (e5, t5) => {
                    P.und(a3[t5]) && (a3[t5] = e5);
                  });
                  const u3 = await r2.start(a3);
                  return f2(s3), n3.paused && await new Promise((e5) => {
                    n3.resumeQueue.add(e5);
                  }), u3;
                })();
              };
              let g2;
              if (N.skipAnimation)
                return Rt(n3), At(r2, false);
              try {
                let t4;
                t4 = P.arr(e3) ? (async (e4) => {
                  for (const t5 of e4)
                    await m2(t5);
                })(e3) : Promise.resolve(e3(m2, r2.stop.bind(r2))), await Promise.all([t4.then(d2), p2]), g2 = At(r2.get(), true, false);
              } catch (e4) {
                if (e4 instanceof Mt)
                  g2 = e4.result;
                else {
                  if (!(e4 instanceof Et))
                    throw e4;
                  g2 = e4.result;
                }
              } finally {
                i2 == n3.asyncId && (n3.asyncId = o2, n3.asyncTo = o2 ? u2 : void 0, n3.promise = o2 ? l2 : void 0);
              }
              return P.fun(a2) && s2.batchedUpdates(() => {
                a2(g2, r2, r2.item);
              }), g2;
            })() : l2;
          }
          function Rt(e3, t3) {
            C(e3.timeouts, (e4) => e4.cancel()), e3.pauseQueue.clear(), e3.resumeQueue.clear(), e3.asyncId = e3.asyncTo = e3.promise = void 0, t3 && (e3.cancelId = t3);
          }
          class Mt extends Error {
            constructor() {
              super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."), this.result = void 0;
            }
          }
          class Et extends Error {
            constructor() {
              super("SkipAnimationSignal"), this.result = void 0;
            }
          }
          const qt = (e3) => e3 instanceof Tt;
          let Nt = 1;
          class Tt extends ve {
            constructor(...e3) {
              super(...e3), this.id = Nt++, this.key = void 0, this._priority = 0;
            }
            get priority() {
              return this._priority;
            }
            set priority(e3) {
              this._priority != e3 && (this._priority = e3, this._onPriorityChange(e3));
            }
            get() {
              const e3 = Qe(this);
              return e3 && e3.getValue();
            }
            to(...e3) {
              return N.to(this, e3);
            }
            interpolate(...e3) {
              return qe(`${Me}The "interpolate" function is deprecated in v9 (use "to" instead)`), N.to(this, e3);
            }
            toJSON() {
              return this.get();
            }
            observerAdded(e3) {
              1 == e3 && this._attach();
            }
            observerRemoved(e3) {
              0 == e3 && this._detach();
            }
            _attach() {
            }
            _detach() {
            }
            _onChange(e3, t3 = false) {
              ye(this, { type: "change", parent: this, value: e3, idle: t3 });
            }
            _onPriorityChange(e3) {
              this.idle || U.sort(this), ye(this, { type: "priority", parent: this, priority: e3 });
            }
          }
          const zt = Symbol.for("SpringPhase"), $t = (e3) => (1 & e3[zt]) > 0, Ft = (e3) => (2 & e3[zt]) > 0, Ut = (e3) => (4 & e3[zt]) > 0, Dt = (e3, t3) => t3 ? e3[zt] |= 3 : e3[zt] &= -3, Lt = (e3, t3) => t3 ? e3[zt] |= 4 : e3[zt] &= -5;
          class Qt extends Tt {
            constructor(e3, t3) {
              if (super(), this.key = void 0, this.animation = new xt(), this.queue = void 0, this.defaultProps = {}, this._state = { paused: false, delayed: false, pauseQueue: /* @__PURE__ */ new Set(), resumeQueue: /* @__PURE__ */ new Set(), timeouts: /* @__PURE__ */ new Set() }, this._pendingCalls = /* @__PURE__ */ new Set(), this._lastCallId = 0, this._lastToId = 0, this._memoizedDuration = 0, !P.und(e3) || !P.und(t3)) {
                const n3 = P.obj(e3) ? ot({}, e3) : ot({}, t3, { from: e3 });
                P.und(n3.default) && (n3.default = true), this.start(n3);
              }
            }
            get idle() {
              return !(Ft(this) || this._state.asyncTo) || Ut(this);
            }
            get goal() {
              return me(this.animation.to);
            }
            get velocity() {
              const e3 = Qe(this);
              return e3 instanceof Ye ? e3.lastVelocity || 0 : e3.getPayload().map((e4) => e4.lastVelocity || 0);
            }
            get hasAnimated() {
              return $t(this);
            }
            get isAnimating() {
              return Ft(this);
            }
            get isPaused() {
              return Ut(this);
            }
            get isDelayed() {
              return this._state.delayed;
            }
            advance(e3) {
              let t3 = true, n3 = false;
              const s3 = this.animation;
              let { config: r2, toValues: i2 } = s3;
              const o2 = Ge(s3.to);
              !o2 && fe(s3.to) && (i2 = O(me(s3.to))), s3.values.forEach((a3, u3) => {
                if (a3.done)
                  return;
                const l2 = a3.constructor == Ze ? 1 : o2 ? o2[u3].lastPosition : i2[u3];
                let c2 = s3.immediate, d2 = l2;
                if (!c2) {
                  if (d2 = a3.lastPosition, r2.tension <= 0)
                    return void (a3.done = true);
                  let t4 = a3.elapsedTime += e3;
                  const n4 = s3.fromValues[u3], i3 = null != a3.v0 ? a3.v0 : a3.v0 = P.arr(r2.velocity) ? r2.velocity[u3] : r2.velocity;
                  let o3;
                  if (P.und(r2.duration))
                    if (r2.decay) {
                      const e4 = true === r2.decay ? 0.998 : r2.decay, s4 = Math.exp(-(1 - e4) * t4);
                      d2 = n4 + i3 / (1 - e4) * (1 - s4), c2 = Math.abs(a3.lastPosition - d2) < 0.1, o3 = i3 * s4;
                    } else {
                      o3 = null == a3.lastVelocity ? i3 : a3.lastVelocity;
                      const t5 = r2.precision || (n4 == l2 ? 5e-3 : Math.min(1, 1e-3 * Math.abs(l2 - n4))), s4 = r2.restVelocity || t5 / 10, u4 = r2.clamp ? 0 : r2.bounce, h2 = !P.und(u4), p2 = n4 == l2 ? a3.v0 > 0 : n4 < l2;
                      let f2, m2 = false;
                      const g2 = 1, y2 = Math.ceil(e3 / g2);
                      for (let e4 = 0; e4 < y2 && (f2 = Math.abs(o3) > s4, f2 || (c2 = Math.abs(l2 - d2) <= t5, !c2)); ++e4)
                        h2 && (m2 = d2 == l2 || d2 > l2 == p2, m2 && (o3 = -o3 * u4, d2 = l2)), o3 += (1e-6 * -r2.tension * (d2 - l2) + 1e-3 * -r2.friction * o3) / r2.mass * g2, d2 += o3 * g2;
                    }
                  else {
                    let s4 = 1;
                    r2.duration > 0 && (this._memoizedDuration !== r2.duration && (this._memoizedDuration = r2.duration, a3.durationProgress > 0 && (a3.elapsedTime = r2.duration * a3.durationProgress, t4 = a3.elapsedTime += e3)), s4 = (r2.progress || 0) + t4 / this._memoizedDuration, s4 = s4 > 1 ? 1 : s4 < 0 ? 0 : s4, a3.durationProgress = s4), d2 = n4 + r2.easing(s4) * (l2 - n4), o3 = (d2 - a3.lastPosition) / e3, c2 = 1 == s4;
                  }
                  a3.lastVelocity = o3, Number.isNaN(d2) && (console.warn("Got NaN while animating:", this), c2 = true);
                }
                o2 && !o2[u3].done && (c2 = false), c2 ? a3.done = true : t3 = false, a3.setValue(d2, r2.round) && (n3 = true);
              });
              const a2 = Qe(this), u2 = a2.getValue();
              if (t3) {
                const e4 = me(s3.to);
                u2 === e4 && !n3 || r2.decay ? n3 && r2.decay && this._onChange(u2) : (a2.setValue(e4), this._onChange(e4)), this._stop();
              } else
                n3 && this._onChange(u2);
            }
            set(e3) {
              return s2.batchedUpdates(() => {
                this._stop(), this._focus(e3), this._set(e3);
              }), this;
            }
            pause() {
              this._update({ pause: true });
            }
            resume() {
              this._update({ pause: false });
            }
            finish() {
              if (Ft(this)) {
                const { to: e3, config: t3 } = this.animation;
                s2.batchedUpdates(() => {
                  this._onStart(), t3.decay || this._set(e3, false), this._stop();
                });
              }
              return this;
            }
            update(e3) {
              return (this.queue || (this.queue = [])).push(e3), this;
            }
            start(e3, t3) {
              let n3;
              return P.und(e3) ? (n3 = this.queue || [], this.queue = []) : n3 = [P.obj(e3) ? e3 : ot({}, t3, { to: e3 })], Promise.all(n3.map((e4) => this._update(e4))).then((e4) => Ot(this, e4));
            }
            stop(e3) {
              const { to: t3 } = this.animation;
              return this._focus(this.get()), Rt(this._state, e3 && this._lastCallId), s2.batchedUpdates(() => this._stop(t3, e3)), this;
            }
            reset() {
              this._update({ reset: true });
            }
            eventObserved(e3) {
              "change" == e3.type ? this._start() : "priority" == e3.type && (this.priority = e3.priority + 1);
            }
            _prepareNode(e3) {
              const t3 = this.key || "";
              let { to: n3, from: s3 } = e3;
              n3 = P.obj(n3) ? n3[t3] : n3, (null == n3 || vt(n3)) && (n3 = void 0), s3 = P.obj(s3) ? s3[t3] : s3, null == s3 && (s3 = void 0);
              const r2 = { to: n3, from: s3 };
              return $t(this) || (e3.reverse && ([n3, s3] = [s3, n3]), s3 = me(s3), P.und(s3) ? Qe(this) || this._set(n3) : this._set(s3)), r2;
            }
            _update(e3, t3) {
              let n3 = ot({}, e3);
              const { key: s3, defaultProps: r2 } = this;
              n3.default && Object.assign(r2, ht(n3, (e4, t4) => /^on/.test(t4) ? lt(e4, s3) : e4)), Jt(this, n3, "onProps"), Xt(this, "onProps", n3, this);
              const i2 = this._prepareNode(n3);
              if (Object.isFrozen(this))
                throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
              const o2 = this._state;
              return Vt(++this._lastCallId, { key: s3, props: n3, defaultProps: r2, state: o2, actions: { pause: () => {
                Ut(this) || (Lt(this, true), A(o2.pauseQueue), Xt(this, "onPause", At(this, Wt(this, this.animation.to)), this));
              }, resume: () => {
                Ut(this) && (Lt(this, false), Ft(this) && this._resume(), A(o2.resumeQueue), Xt(this, "onResume", At(this, Wt(this, this.animation.to)), this));
              }, start: this._merge.bind(this, i2) } }).then((e4) => {
                if (n3.loop && e4.finished && (!t3 || !e4.noop)) {
                  const e5 = Gt(n3);
                  if (e5)
                    return this._update(e5, true);
                }
                return e4;
              });
            }
            _merge(e3, t3, n3) {
              if (t3.cancel)
                return this.stop(true), n3(It(this));
              const r2 = !P.und(e3.to), i2 = !P.und(e3.from);
              if (r2 || i2) {
                if (!(t3.callId > this._lastToId))
                  return n3(It(this));
                this._lastToId = t3.callId;
              }
              const { key: o2, defaultProps: a2, animation: u2 } = this, { to: l2, from: c2 } = u2;
              let { to: d2 = l2, from: h2 = c2 } = e3;
              !i2 || r2 || t3.default && !P.und(d2) || (d2 = h2), t3.reverse && ([d2, h2] = [h2, d2]);
              const p2 = !S(h2, c2);
              p2 && (u2.from = h2), h2 = me(h2);
              const f2 = !S(d2, l2);
              f2 && this._focus(d2);
              const m2 = vt(t3.to), { config: g2 } = u2, { decay: y2, velocity: v2 } = g2;
              (r2 || i2) && (g2.velocity = 0), t3.config && !m2 && function(e4, t4, n4) {
                n4 && (Pt(n4 = ot({}, n4), t4), t4 = ot({}, n4, t4)), Pt(e4, t4), Object.assign(e4, t4);
                for (const t5 in wt)
                  null == e4[t5] && (e4[t5] = wt[t5]);
                let { mass: s3, frequency: r3, damping: i3 } = e4;
                P.und(r3) || (r3 < 0.01 && (r3 = 0.01), i3 < 0 && (i3 = 0), e4.tension = Math.pow(2 * Math.PI / r3, 2) * s3, e4.friction = 4 * Math.PI * i3 * s3 / r3);
              }(g2, at(t3.config, o2), t3.config !== a2.config ? at(a2.config, o2) : void 0);
              let b2 = Qe(this);
              if (!b2 || P.und(d2))
                return n3(At(this, true));
              const _2 = P.und(t3.reset) ? i2 && !t3.default : !P.und(h2) && ut(t3.reset, o2), w2 = _2 ? h2 : this.get(), k2 = gt(d2), V2 = P.num(k2) || P.arr(k2) || Te(k2), C2 = !m2 && (!V2 || ut(a2.immediate || t3.immediate, o2));
              if (f2) {
                const e4 = et(d2);
                if (e4 !== b2.constructor) {
                  if (!C2)
                    throw Error(`Cannot animate between ${b2.constructor.name} and ${e4.name}, as the "to" prop suggests`);
                  b2 = this._set(k2);
                }
              }
              const I2 = b2.constructor;
              let j2 = fe(d2), R2 = false;
              if (!j2) {
                const e4 = _2 || !$t(this) && p2;
                (f2 || e4) && (R2 = S(gt(w2), k2), j2 = !R2), (S(u2.immediate, C2) || C2) && S(g2.decay, y2) && S(g2.velocity, v2) || (j2 = true);
              }
              if (R2 && Ft(this) && (u2.changed && !_2 ? j2 = true : j2 || this._stop(l2)), !m2 && ((j2 || fe(l2)) && (u2.values = b2.getPayload(), u2.toValues = fe(d2) ? null : I2 == Ze ? [1] : O(k2)), u2.immediate != C2 && (u2.immediate = C2, C2 || _2 || this._set(l2)), j2)) {
                const { onRest: e4 } = u2;
                x(Ht, (e5) => Jt(this, t3, e5));
                const r3 = At(this, Wt(this, l2));
                A(this._pendingCalls, r3), this._pendingCalls.add(n3), u2.changed && s2.batchedUpdates(() => {
                  u2.changed = !_2, null == e4 || e4(r3, this), _2 ? at(a2.onRest, r3) : null == u2.onStart || u2.onStart(r3, this);
                });
              }
              _2 && this._set(w2), m2 ? n3(jt(t3.to, t3, this._state, this)) : j2 ? this._start() : Ft(this) && !f2 ? this._pendingCalls.add(n3) : n3(Ct(w2));
            }
            _focus(e3) {
              const t3 = this.animation;
              e3 !== t3.to && (ge(this) && this._detach(), t3.to = e3, ge(this) && this._attach());
            }
            _attach() {
              let e3 = 0;
              const { to: t3 } = this.animation;
              fe(t3) && (_e(t3, this), qt(t3) && (e3 = t3.priority + 1)), this.priority = e3;
            }
            _detach() {
              const { to: e3 } = this.animation;
              fe(e3) && we(e3, this);
            }
            _set(e3, t3 = true) {
              const n3 = me(e3);
              if (!P.und(n3)) {
                const e4 = Qe(this);
                if (!e4 || !S(n3, e4.getValue())) {
                  const r2 = et(n3);
                  e4 && e4.constructor == r2 ? e4.setValue(n3) : We(this, r2.create(n3)), e4 && s2.batchedUpdates(() => {
                    this._onChange(n3, t3);
                  });
                }
              }
              return Qe(this);
            }
            _onStart() {
              const e3 = this.animation;
              e3.changed || (e3.changed = true, Xt(this, "onStart", At(this, Wt(this, e3.to)), this));
            }
            _onChange(e3, t3) {
              t3 || (this._onStart(), at(this.animation.onChange, e3, this)), at(this.defaultProps.onChange, e3, this), super._onChange(e3, t3);
            }
            _start() {
              const e3 = this.animation;
              Qe(this).reset(me(e3.to)), e3.immediate || (e3.fromValues = e3.values.map((e4) => e4.lastPosition)), Ft(this) || (Dt(this, true), Ut(this) || this._resume());
            }
            _resume() {
              N.skipAnimation ? this.finish() : U.start(this);
            }
            _stop(e3, t3) {
              if (Ft(this)) {
                Dt(this, false);
                const n3 = this.animation;
                x(n3.values, (e4) => {
                  e4.done = true;
                }), n3.toValues && (n3.onChange = n3.onPause = n3.onResume = void 0), ye(this, { type: "idle", parent: this });
                const s3 = t3 ? It(this.get()) : At(this.get(), Wt(this, null != e3 ? e3 : n3.to));
                A(this._pendingCalls, s3), n3.changed && (n3.changed = false, Xt(this, "onRest", s3, this));
              }
            }
          }
          function Wt(e3, t3) {
            const n3 = gt(t3);
            return S(gt(e3.get()), n3);
          }
          function Gt(e3, t3 = e3.loop, n3 = e3.to) {
            let s3 = at(t3);
            if (s3) {
              const r2 = true !== s3 && mt(s3), i2 = (r2 || e3).reverse, o2 = !r2 || r2.reset;
              return Bt(ot({}, e3, { loop: t3, default: false, pause: void 0, to: !i2 || vt(n3) ? n3 : void 0, from: o2 ? e3.from : void 0, reset: o2 }, r2));
            }
          }
          function Bt(e3) {
            const { to: t3, from: n3 } = e3 = mt(e3), s3 = /* @__PURE__ */ new Set();
            return P.obj(t3) && Zt(t3, s3), P.obj(n3) && Zt(n3, s3), e3.keys = s3.size ? Array.from(s3) : null, e3;
          }
          function Yt(e3) {
            const t3 = Bt(e3);
            return P.und(t3.default) && (t3.default = ht(t3)), t3;
          }
          function Zt(e3, t3) {
            V(e3, (e4, n3) => null != e4 && t3.add(n3));
          }
          const Ht = ["onStart", "onRest", "onChange", "onPause", "onResume"];
          function Jt(e3, t3, n3) {
            e3.animation[n3] = t3[n3] !== ct(t3, n3) ? lt(t3[n3], e3.key) : void 0;
          }
          function Xt(e3, t3, ...n3) {
            var s3, r2, i2, o2;
            null == (s3 = (r2 = e3.animation)[t3]) || s3.call(r2, ...n3), null == (i2 = (o2 = e3.defaultProps)[t3]) || i2.call(o2, ...n3);
          }
          const Kt = ["onStart", "onChange", "onRest"];
          let en = 1;
          class tn {
            constructor(e3, t3) {
              this.id = en++, this.springs = {}, this.queue = [], this.ref = void 0, this._flush = void 0, this._initialProps = void 0, this._lastAsyncId = 0, this._active = /* @__PURE__ */ new Set(), this._changed = /* @__PURE__ */ new Set(), this._started = false, this._item = void 0, this._state = { paused: false, pauseQueue: /* @__PURE__ */ new Set(), resumeQueue: /* @__PURE__ */ new Set(), timeouts: /* @__PURE__ */ new Set() }, this._events = { onStart: /* @__PURE__ */ new Map(), onChange: /* @__PURE__ */ new Map(), onRest: /* @__PURE__ */ new Map() }, this._onFrame = this._onFrame.bind(this), t3 && (this._flush = t3), e3 && this.start(ot({ default: true }, e3));
            }
            get idle() {
              return !this._state.asyncTo && Object.values(this.springs).every((e3) => e3.idle && !e3.isDelayed && !e3.isPaused);
            }
            get item() {
              return this._item;
            }
            set item(e3) {
              this._item = e3;
            }
            get() {
              const e3 = {};
              return this.each((t3, n3) => e3[n3] = t3.get()), e3;
            }
            set(e3) {
              for (const t3 in e3) {
                const n3 = e3[t3];
                P.und(n3) || this.springs[t3].set(n3);
              }
            }
            update(e3) {
              return e3 && this.queue.push(Bt(e3)), this;
            }
            start(e3) {
              let { queue: t3 } = this;
              return e3 ? t3 = O(e3).map(Bt) : this.queue = [], this._flush ? this._flush(this, t3) : (ln(this, t3), nn(this, t3));
            }
            stop(e3, t3) {
              if (e3 !== !!e3 && (t3 = e3), t3) {
                const n3 = this.springs;
                x(O(t3), (t4) => n3[t4].stop(!!e3));
              } else
                Rt(this._state, this._lastAsyncId), this.each((t4) => t4.stop(!!e3));
              return this;
            }
            pause(e3) {
              if (P.und(e3))
                this.start({ pause: true });
              else {
                const t3 = this.springs;
                x(O(e3), (e4) => t3[e4].pause());
              }
              return this;
            }
            resume(e3) {
              if (P.und(e3))
                this.start({ pause: false });
              else {
                const t3 = this.springs;
                x(O(e3), (e4) => t3[e4].resume());
              }
              return this;
            }
            each(e3) {
              V(this.springs, e3);
            }
            _onFrame() {
              const { onStart: e3, onChange: t3, onRest: n3 } = this._events, s3 = this._active.size > 0, r2 = this._changed.size > 0;
              (s3 && !this._started || r2 && !this._started) && (this._started = true, C(e3, ([e4, t4]) => {
                t4.value = this.get(), e4(t4, this, this._item);
              }));
              const i2 = !s3 && this._started, o2 = r2 || i2 && n3.size ? this.get() : null;
              r2 && t3.size && C(t3, ([e4, t4]) => {
                t4.value = o2, e4(t4, this, this._item);
              }), i2 && (this._started = false, C(n3, ([e4, t4]) => {
                t4.value = o2, e4(t4, this, this._item);
              }));
            }
            eventObserved(e3) {
              if ("change" == e3.type)
                this._changed.add(e3.parent), e3.idle || this._active.add(e3.parent);
              else {
                if ("idle" != e3.type)
                  return;
                this._active.delete(e3.parent);
              }
              s2.onFrame(this._onFrame);
            }
          }
          function nn(e3, t3) {
            return Promise.all(t3.map((t4) => sn(e3, t4))).then((t4) => Ot(e3, t4));
          }
          async function sn(e3, t3, n3) {
            const { keys: r2, to: i2, from: o2, loop: a2, onRest: u2, onResolve: l2 } = t3, c2 = P.obj(t3.default) && t3.default;
            a2 && (t3.loop = false), false === i2 && (t3.to = null), false === o2 && (t3.from = null);
            const d2 = P.arr(i2) || P.fun(i2) ? i2 : void 0;
            d2 ? (t3.to = void 0, t3.onRest = void 0, c2 && (c2.onRest = void 0)) : x(Kt, (n4) => {
              const s3 = t3[n4];
              if (P.fun(s3)) {
                const r3 = e3._events[n4];
                t3[n4] = ({ finished: e4, cancelled: t4 }) => {
                  const n5 = r3.get(s3);
                  n5 ? (e4 || (n5.finished = false), t4 && (n5.cancelled = true)) : r3.set(s3, { value: null, finished: e4 || false, cancelled: t4 || false });
                }, c2 && (c2[n4] = t3[n4]);
              }
            });
            const h2 = e3._state;
            t3.pause === !h2.paused ? (h2.paused = t3.pause, A(t3.pause ? h2.pauseQueue : h2.resumeQueue)) : h2.paused && (t3.pause = true);
            const p2 = (r2 || Object.keys(e3.springs)).map((n4) => e3.springs[n4].start(t3)), f2 = true === t3.cancel || true === ct(t3, "cancel");
            (d2 || f2 && h2.asyncId) && p2.push(Vt(++e3._lastAsyncId, { props: t3, state: h2, actions: { pause: k, resume: k, start(t4, n4) {
              f2 ? (Rt(h2, e3._lastAsyncId), n4(It(e3))) : (t4.onRest = u2, n4(jt(d2, t4, h2, e3)));
            } } })), h2.paused && await new Promise((e4) => {
              h2.resumeQueue.add(e4);
            });
            const m2 = Ot(e3, await Promise.all(p2));
            if (a2 && m2.finished && (!n3 || !m2.noop)) {
              const n4 = Gt(t3, a2, i2);
              if (n4)
                return ln(e3, [n4]), sn(e3, n4, true);
            }
            return l2 && s2.batchedUpdates(() => l2(m2, e3, e3.item)), m2;
          }
          function rn(e3, t3) {
            const n3 = ot({}, e3.springs);
            return t3 && x(O(t3), (e4) => {
              P.und(e4.keys) && (e4 = Bt(e4)), P.obj(e4.to) || (e4 = ot({}, e4, { to: void 0 })), un(n3, e4, (e5) => an(e5));
            }), on(e3, n3), n3;
          }
          function on(e3, t3) {
            V(t3, (t4, n3) => {
              e3.springs[n3] || (e3.springs[n3] = t4, _e(t4, e3));
            });
          }
          function an(e3, t3) {
            const n3 = new Qt();
            return n3.key = e3, t3 && _e(n3, t3), n3;
          }
          function un(e3, t3, n3) {
            t3.keys && x(t3.keys, (s3) => {
              (e3[s3] || (e3[s3] = n3(s3)))._prepareNode(t3);
            });
          }
          function ln(e3, t3) {
            x(t3, (t4) => {
              un(e3.springs, t4, (t5) => an(t5, e3));
            });
          }
          function cn(e3, t3) {
            if (null == e3)
              return {};
            var n3, s3, r2 = {}, i2 = Object.keys(e3);
            for (s3 = 0; s3 < i2.length; s3++)
              n3 = i2[s3], t3.indexOf(n3) >= 0 || (r2[n3] = e3[n3]);
            return r2;
          }
          const dn = ["children"], hn = (t3) => {
            let { children: n3 } = t3, s3 = cn(t3, dn);
            const r2 = (0, e2.useContext)(pn), i2 = s3.pause || !!r2.pause, o2 = s3.immediate || !!r2.immediate;
            s3 = function(t4, n4) {
              const [s4] = (0, e2.useState)(() => ({ inputs: n4, result: t4() })), r3 = (0, e2.useRef)(), i3 = r3.current;
              let o3 = i3;
              return o3 ? Boolean(n4 && o3.inputs && function(e3, t5) {
                if (e3.length !== t5.length)
                  return false;
                for (let n5 = 0; n5 < e3.length; n5++)
                  if (e3[n5] !== t5[n5])
                    return false;
                return true;
              }(n4, o3.inputs)) || (o3 = { inputs: n4, result: t4() }) : o3 = s4, (0, e2.useEffect)(() => {
                r3.current = o3, i3 == s4 && (s4.inputs = s4.result = void 0);
              }, [o3]), o3.result;
            }(() => ({ pause: i2, immediate: o2 }), [i2, o2]);
            const { Provider: a2 } = pn;
            return e2.createElement(a2, { value: s3 }, n3);
          }, pn = (fn = hn, mn = {}, Object.assign(fn, e2.createContext(mn)), fn.Provider._context = fn, fn.Consumer._context = fn, fn);
          var fn, mn;
          hn.Provider = pn.Provider, hn.Consumer = pn.Consumer;
          const gn = () => {
            const e3 = [], t3 = function(t4) {
              Ne(`${Me}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`);
              const s3 = [];
              return x(e3, (e4, r2) => {
                if (P.und(t4))
                  s3.push(e4.start());
                else {
                  const i2 = n3(t4, e4, r2);
                  i2 && s3.push(e4.start(i2));
                }
              }), s3;
            };
            t3.current = e3, t3.add = function(t4) {
              e3.includes(t4) || e3.push(t4);
            }, t3.delete = function(t4) {
              const n4 = e3.indexOf(t4);
              ~n4 && e3.splice(n4, 1);
            }, t3.pause = function() {
              return x(e3, (e4) => e4.pause(...arguments)), this;
            }, t3.resume = function() {
              return x(e3, (e4) => e4.resume(...arguments)), this;
            }, t3.set = function(t4) {
              x(e3, (e4) => e4.set(t4));
            }, t3.start = function(t4) {
              const n4 = [];
              return x(e3, (e4, s3) => {
                if (P.und(t4))
                  n4.push(e4.start());
                else {
                  const r2 = this._getProps(t4, e4, s3);
                  r2 && n4.push(e4.start(r2));
                }
              }), n4;
            }, t3.stop = function() {
              return x(e3, (e4) => e4.stop(...arguments)), this;
            }, t3.update = function(t4) {
              return x(e3, (e4, n4) => e4.update(this._getProps(t4, e4, n4))), this;
            };
            const n3 = function(e4, t4, n4) {
              return P.fun(e4) ? e4(n4, t4) : e4;
            };
            return t3._getProps = n3, t3;
          };
          function yn(t3, n3, s3) {
            const r2 = P.fun(n3) && n3;
            r2 && !s3 && (s3 = []);
            const i2 = (0, e2.useMemo)(() => r2 || 3 == arguments.length ? gn() : void 0, []), o2 = (0, e2.useRef)(0), a2 = $e(), u2 = (0, e2.useMemo)(() => ({ ctrls: [], queue: [], flush(e3, t4) {
              const n4 = rn(e3, t4);
              return o2.current > 0 && !u2.queue.length && !Object.keys(n4).some((t5) => !e3.springs[t5]) ? nn(e3, t4) : new Promise((s4) => {
                on(e3, n4), u2.queue.push(() => {
                  s4(nn(e3, t4));
                }), a2();
              });
            } }), []), l2 = (0, e2.useRef)([...u2.ctrls]), c2 = [], d2 = De(t3) || 0;
            function h2(e3, t4) {
              for (let s4 = e3; s4 < t4; s4++) {
                const e4 = l2.current[s4] || (l2.current[s4] = new tn(null, u2.flush)), t5 = r2 ? r2(s4, e4) : n3[s4];
                t5 && (c2[s4] = Yt(t5));
              }
            }
            (0, e2.useMemo)(() => {
              x(l2.current.slice(t3, d2), (e3) => {
                bt(e3, i2), e3.stop(true);
              }), l2.current.length = t3, h2(d2, t3);
            }, [t3]), (0, e2.useMemo)(() => {
              h2(0, Math.min(d2, t3));
            }, s3);
            const p2 = l2.current.map((e3, t4) => rn(e3, c2[t4])), f2 = (0, e2.useContext)(hn), m2 = De(f2), g2 = f2 !== m2 && yt(f2);
            ze(() => {
              o2.current++, u2.ctrls = l2.current;
              const { queue: e3 } = u2;
              e3.length && (u2.queue = [], x(e3, (e4) => e4())), x(l2.current, (e4, t4) => {
                null == i2 || i2.add(e4), g2 && e4.start({ default: f2 });
                const n4 = c2[t4];
                n4 && (_t(e4, n4.ref), e4.ref ? e4.queue.push(n4) : e4.start(n4));
              });
            }), Fe(() => () => {
              x(u2.ctrls, (e3) => e3.stop(true));
            });
            const y2 = p2.map((e3) => ot({}, e3));
            return i2 ? [y2, i2] : y2;
          }
          let vn;
          !function(e3) {
            e3.MOUNT = "mount", e3.ENTER = "enter", e3.UPDATE = "update", e3.LEAVE = "leave";
          }(vn || (vn = {}));
          const bn = ["children"];
          function _n(e3) {
            let { children: t3 } = e3;
            return t3(function(e4, t4) {
              const n3 = P.fun(e4), [[s3], r2] = yn(1, n3 ? e4 : [e4], n3 ? t4 || [] : t4);
              return n3 || 2 == arguments.length ? [s3, r2] : s3;
            }(cn(e3, bn)));
          }
          class wn extends Tt {
            constructor(e3, t3) {
              super(), this.key = void 0, this.idle = true, this.calc = void 0, this._active = /* @__PURE__ */ new Set(), this.source = e3, this.calc = ce(...t3);
              const n3 = this._get(), s3 = et(n3);
              We(this, s3.create(n3));
            }
            advance(e3) {
              const t3 = this._get();
              S(t3, this.get()) || (Qe(this).setValue(t3), this._onChange(t3, this.idle)), !this.idle && Pn(this._active) && Sn(this);
            }
            _get() {
              const e3 = P.arr(this.source) ? this.source.map(me) : O(me(this.source));
              return this.calc(...e3);
            }
            _start() {
              this.idle && !Pn(this._active) && (this.idle = false, x(Ge(this), (e3) => {
                e3.done = false;
              }), N.skipAnimation ? (s2.batchedUpdates(() => this.advance()), Sn(this)) : U.start(this));
            }
            _attach() {
              let e3 = 1;
              x(O(this.source), (t3) => {
                fe(t3) && _e(t3, this), qt(t3) && (t3.idle || this._active.add(t3), e3 = Math.max(e3, t3.priority + 1));
              }), this.priority = e3, this._start();
            }
            _detach() {
              x(O(this.source), (e3) => {
                fe(e3) && we(e3, this);
              }), this._active.clear(), Sn(this);
            }
            eventObserved(e3) {
              "change" == e3.type ? e3.idle ? this.advance() : (this._active.add(e3.parent), this._start()) : "idle" == e3.type ? this._active.delete(e3.parent) : "priority" == e3.type && (this.priority = O(this.source).reduce((e4, t3) => Math.max(e4, (qt(t3) ? t3.priority : 0) + 1), 0));
            }
          }
          function kn(e3) {
            return false !== e3.idle;
          }
          function Pn(e3) {
            return !e3.size || Array.from(e3).every(kn);
          }
          function Sn(e3) {
            e3.idle || (e3.idle = true, x(Ge(e3), (e4) => {
              e4.done = true;
            }), ye(e3, { type: "idle", parent: e3 }));
          }
          N.assign({ createStringInterpolator: Re, to: (e3, t3) => new wn(e3, t3) }), U.advance;
          var xn = r(268);
          function Vn(e3, t3) {
            if (null == e3)
              return {};
            var n3, s3, r2 = {}, i2 = Object.keys(e3);
            for (s3 = 0; s3 < i2.length; s3++)
              n3 = i2[s3], t3.indexOf(n3) >= 0 || (r2[n3] = e3[n3]);
            return r2;
          }
          const On = ["style", "children", "scrollTop", "scrollLeft"], Cn = /^--/;
          function An(e3, t3) {
            return null == t3 || "boolean" == typeof t3 || "" === t3 ? "" : "number" != typeof t3 || 0 === t3 || Cn.test(e3) || jn.hasOwnProperty(e3) && jn[e3] ? ("" + t3).trim() : t3 + "px";
          }
          const In = {};
          let jn = { animationIterationCount: true, borderImageOutset: true, borderImageSlice: true, borderImageWidth: true, boxFlex: true, boxFlexGroup: true, boxOrdinalGroup: true, columnCount: true, columns: true, flex: true, flexGrow: true, flexPositive: true, flexShrink: true, flexNegative: true, flexOrder: true, gridRow: true, gridRowEnd: true, gridRowSpan: true, gridRowStart: true, gridColumn: true, gridColumnEnd: true, gridColumnSpan: true, gridColumnStart: true, fontWeight: true, lineClamp: true, lineHeight: true, opacity: true, order: true, orphans: true, tabSize: true, widows: true, zIndex: true, zoom: true, fillOpacity: true, floodOpacity: true, stopOpacity: true, strokeDasharray: true, strokeDashoffset: true, strokeMiterlimit: true, strokeOpacity: true, strokeWidth: true };
          const Rn = ["Webkit", "Ms", "Moz", "O"];
          jn = Object.keys(jn).reduce((e3, t3) => (Rn.forEach((n3) => e3[((e4, t4) => e4 + t4.charAt(0).toUpperCase() + t4.substring(1))(n3, t3)] = e3[t3]), e3), jn);
          const Mn = ["x", "y", "z"], En = /^(matrix|translate|scale|rotate|skew)/, qn = /^(translate)/, Nn = /^(rotate|skew)/, Tn = (e3, t3) => P.num(e3) && 0 !== e3 ? e3 + t3 : e3, zn = (e3, t3) => P.arr(e3) ? e3.every((e4) => zn(e4, t3)) : P.num(e3) ? e3 === t3 : parseFloat(e3) === t3;
          class $n extends Je {
            constructor(e3) {
              let { x: t3, y: n3, z: s3 } = e3, r2 = Vn(e3, Mn);
              const i2 = [], o2 = [];
              (t3 || n3 || s3) && (i2.push([t3 || 0, n3 || 0, s3 || 0]), o2.push((e4) => [`translate3d(${e4.map((e5) => Tn(e5, "px")).join(",")})`, zn(e4, 0)])), V(r2, (e4, t4) => {
                if ("transform" === t4)
                  i2.push([e4 || ""]), o2.push((e5) => [e5, "" === e5]);
                else if (En.test(t4)) {
                  if (delete r2[t4], P.und(e4))
                    return;
                  const n4 = qn.test(t4) ? "px" : Nn.test(t4) ? "deg" : "";
                  i2.push(O(e4)), o2.push("rotate3d" === t4 ? ([e5, t5, s4, r3]) => [`rotate3d(${e5},${t5},${s4},${Tn(r3, n4)})`, zn(r3, 0)] : (e5) => [`${t4}(${e5.map((e6) => Tn(e6, n4)).join(",")})`, zn(e5, t4.startsWith("scale") ? 1 : 0)]);
                }
              }), i2.length && (r2.transform = new Fn(i2, o2)), super(r2);
            }
          }
          class Fn extends ve {
            constructor(e3, t3) {
              super(), this._value = null, this.inputs = e3, this.transforms = t3;
            }
            get() {
              return this._value || (this._value = this._get());
            }
            _get() {
              let e3 = "", t3 = true;
              return x(this.inputs, (n3, s3) => {
                const r2 = me(n3[0]), [i2, o2] = this.transforms[s3](P.arr(r2) ? r2 : n3.map(me));
                e3 += " " + i2, t3 = t3 && o2;
              }), t3 ? "none" : e3;
            }
            observerAdded(e3) {
              1 == e3 && x(this.inputs, (e4) => x(e4, (e5) => fe(e5) && _e(e5, this)));
            }
            observerRemoved(e3) {
              0 == e3 && x(this.inputs, (e4) => x(e4, (e5) => fe(e5) && we(e5, this)));
            }
            eventObserved(e3) {
              "change" == e3.type && (this._value = null), ye(this, e3);
            }
          }
          const Un = ["scrollTop", "scrollLeft"];
          N.assign({ batchedUpdates: xn.unstable_batchedUpdates, createStringInterpolator: Re, colors: { transparent: 0, aliceblue: 4042850303, antiquewhite: 4209760255, aqua: 16777215, aquamarine: 2147472639, azure: 4043309055, beige: 4126530815, bisque: 4293182719, black: 255, blanchedalmond: 4293643775, blue: 65535, blueviolet: 2318131967, brown: 2771004159, burlywood: 3736635391, burntsienna: 3934150143, cadetblue: 1604231423, chartreuse: 2147418367, chocolate: 3530104575, coral: 4286533887, cornflowerblue: 1687547391, cornsilk: 4294499583, crimson: 3692313855, cyan: 16777215, darkblue: 35839, darkcyan: 9145343, darkgoldenrod: 3095792639, darkgray: 2846468607, darkgreen: 6553855, darkgrey: 2846468607, darkkhaki: 3182914559, darkmagenta: 2332068863, darkolivegreen: 1433087999, darkorange: 4287365375, darkorchid: 2570243327, darkred: 2332033279, darksalmon: 3918953215, darkseagreen: 2411499519, darkslateblue: 1211993087, darkslategray: 793726975, darkslategrey: 793726975, darkturquoise: 13554175, darkviolet: 2483082239, deeppink: 4279538687, deepskyblue: 12582911, dimgray: 1768516095, dimgrey: 1768516095, dodgerblue: 512819199, firebrick: 2988581631, floralwhite: 4294635775, forestgreen: 579543807, fuchsia: 4278255615, gainsboro: 3705462015, ghostwhite: 4177068031, gold: 4292280575, goldenrod: 3668254975, gray: 2155905279, green: 8388863, greenyellow: 2919182335, grey: 2155905279, honeydew: 4043305215, hotpink: 4285117695, indianred: 3445382399, indigo: 1258324735, ivory: 4294963455, khaki: 4041641215, lavender: 3873897215, lavenderblush: 4293981695, lawngreen: 2096890111, lemonchiffon: 4294626815, lightblue: 2916673279, lightcoral: 4034953471, lightcyan: 3774873599, lightgoldenrodyellow: 4210742015, lightgray: 3553874943, lightgreen: 2431553791, lightgrey: 3553874943, lightpink: 4290167295, lightsalmon: 4288707327, lightseagreen: 548580095, lightskyblue: 2278488831, lightslategray: 2005441023, lightslategrey: 2005441023, lightsteelblue: 2965692159, lightyellow: 4294959359, lime: 16711935, limegreen: 852308735, linen: 4210091775, magenta: 4278255615, maroon: 2147483903, mediumaquamarine: 1724754687, mediumblue: 52735, mediumorchid: 3126187007, mediumpurple: 2473647103, mediumseagreen: 1018393087, mediumslateblue: 2070474495, mediumspringgreen: 16423679, mediumturquoise: 1221709055, mediumvioletred: 3340076543, midnightblue: 421097727, mintcream: 4127193855, mistyrose: 4293190143, moccasin: 4293178879, navajowhite: 4292783615, navy: 33023, oldlace: 4260751103, olive: 2155872511, olivedrab: 1804477439, orange: 4289003775, orangered: 4282712319, orchid: 3664828159, palegoldenrod: 4008225535, palegreen: 2566625535, paleturquoise: 2951671551, palevioletred: 3681588223, papayawhip: 4293907967, peachpuff: 4292524543, peru: 3448061951, pink: 4290825215, plum: 3718307327, powderblue: 2967529215, purple: 2147516671, rebeccapurple: 1714657791, red: 4278190335, rosybrown: 3163525119, royalblue: 1097458175, saddlebrown: 2336560127, salmon: 4202722047, sandybrown: 4104413439, seagreen: 780883967, seashell: 4294307583, sienna: 2689740287, silver: 3233857791, skyblue: 2278484991, slateblue: 1784335871, slategray: 1887473919, slategrey: 1887473919, snow: 4294638335, springgreen: 16744447, steelblue: 1182971135, tan: 3535047935, teal: 8421631, thistle: 3636451583, tomato: 4284696575, turquoise: 1088475391, violet: 4001558271, wheat: 4125012991, white: 4294967295, whitesmoke: 4126537215, yellow: 4294902015, yellowgreen: 2597139199 } });
          const Dn = ((e3, { applyAnimatedValues: t3 = () => false, createAnimatedStyle: n3 = (e4) => new Je(e4), getComponentProps: s3 = (e4) => e4 } = {}) => {
            const r2 = { applyAnimatedValues: t3, createAnimatedStyle: n3, getComponentProps: s3 }, i2 = (e4) => {
              const t4 = it(e4) || "Anonymous";
              return (e4 = P.str(e4) ? i2[e4] || (i2[e4] = nt(e4, r2)) : e4[rt] || (e4[rt] = nt(e4, r2))).displayName = `Animated(${t4})`, e4;
            };
            return V(e3, (t4, n4) => {
              P.arr(e3) && (n4 = it(t4)), i2[n4] = i2(t4);
            }), { animated: i2 };
          })(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"], { applyAnimatedValues: function(e3, t3) {
            if (!e3.nodeType || !e3.setAttribute)
              return false;
            const n3 = "filter" === e3.nodeName || e3.parentNode && "filter" === e3.parentNode.nodeName, s3 = t3, { style: r2, children: i2, scrollTop: o2, scrollLeft: a2 } = s3, u2 = Vn(s3, On), l2 = Object.values(u2), c2 = Object.keys(u2).map((t4) => n3 || e3.hasAttribute(t4) ? t4 : In[t4] || (In[t4] = t4.replace(/([A-Z])/g, (e4) => "-" + e4.toLowerCase())));
            void 0 !== i2 && (e3.textContent = i2);
            for (let t4 in r2)
              if (r2.hasOwnProperty(t4)) {
                const n4 = An(t4, r2[t4]);
                Cn.test(t4) ? e3.style.setProperty(t4, n4) : e3.style[t4] = n4;
              }
            c2.forEach((t4, n4) => {
              e3.setAttribute(t4, l2[n4]);
            }), void 0 !== o2 && (e3.scrollTop = o2), void 0 !== a2 && (e3.scrollLeft = a2);
          }, createAnimatedStyle: (e3) => new $n(e3), getComponentProps: (e3) => Vn(e3, Un) }).animated;
          function Ln() {
            return (Ln = Object.assign || function(e3) {
              for (var t3 = 1; t3 < arguments.length; t3++) {
                var n3 = arguments[t3];
                for (var s3 in n3)
                  Object.prototype.hasOwnProperty.call(n3, s3) && (e3[s3] = n3[s3]);
              }
              return e3;
            }).apply(this, arguments);
          }
          function Qn(e3, t3) {
            return (Qn = Object.setPrototypeOf || function(e4, t4) {
              return e4.__proto__ = t4, e4;
            })(e3, t3);
          }
          var Wn = /* @__PURE__ */ new Map(), Gn = /* @__PURE__ */ new WeakMap(), Bn = 0;
          function Yn(e3, t3, n3, s3) {
            if (void 0 === n3 && (n3 = {}), void 0 === s3 && (s3 = void 0), void 0 === window.IntersectionObserver && void 0 !== s3) {
              var r2 = e3.getBoundingClientRect();
              return t3(s3, { isIntersecting: s3, target: e3, intersectionRatio: "number" == typeof n3.threshold ? n3.threshold : 0, time: 0, boundingClientRect: r2, intersectionRect: r2, rootBounds: r2 }), function() {
              };
            }
            var i2 = function(e4) {
              var t4 = function(e5) {
                return Object.keys(e5).sort().filter(function(t5) {
                  return void 0 !== e5[t5];
                }).map(function(t5) {
                  return t5 + "_" + ("root" === t5 ? (n5 = e5.root) ? (Gn.has(n5) || (Bn += 1, Gn.set(n5, Bn.toString())), Gn.get(n5)) : "0" : e5[t5]);
                  var n5;
                }).toString();
              }(e4), n4 = Wn.get(t4);
              if (!n4) {
                var s4, r3 = /* @__PURE__ */ new Map(), i3 = new IntersectionObserver(function(t5) {
                  t5.forEach(function(t6) {
                    var n5, i4 = t6.isIntersecting && s4.some(function(e5) {
                      return t6.intersectionRatio >= e5;
                    });
                    e4.trackVisibility && void 0 === t6.isVisible && (t6.isVisible = i4), null == (n5 = r3.get(t6.target)) || n5.forEach(function(e5) {
                      e5(i4, t6);
                    });
                  });
                }, e4);
                s4 = i3.thresholds || (Array.isArray(e4.threshold) ? e4.threshold : [e4.threshold || 0]), n4 = { id: t4, observer: i3, elements: r3 }, Wn.set(t4, n4);
              }
              return n4;
            }(n3), o2 = i2.id, a2 = i2.observer, u2 = i2.elements, l2 = u2.get(e3) || [];
            return u2.has(e3) || u2.set(e3, l2), l2.push(t3), a2.observe(e3), function() {
              l2.splice(l2.indexOf(t3), 1), 0 === l2.length && (u2.delete(e3), a2.unobserve(e3)), 0 === u2.size && (a2.disconnect(), Wn.delete(o2));
            };
          }
          var Zn = ["children", "as", "tag", "triggerOnce", "threshold", "root", "rootMargin", "onChange", "skip", "trackVisibility", "delay", "initialInView", "fallbackInView"];
          function Hn(e3) {
            return "function" != typeof e3.children;
          }
          var Jn = function(t3) {
            var n3, s3;
            function r2(e3) {
              var n4;
              return (n4 = t3.call(this, e3) || this).node = null, n4._unobserveCb = null, n4.handleNode = function(e4) {
                n4.node && (n4.unobserve(), e4 || n4.props.triggerOnce || n4.props.skip || n4.setState({ inView: !!n4.props.initialInView, entry: void 0 })), n4.node = e4 || null, n4.observeNode();
              }, n4.handleChange = function(e4, t4) {
                e4 && n4.props.triggerOnce && n4.unobserve(), Hn(n4.props) || n4.setState({ inView: e4, entry: t4 }), n4.props.onChange && n4.props.onChange(e4, t4);
              }, n4.state = { inView: !!e3.initialInView, entry: void 0 }, n4;
            }
            s3 = t3, (n3 = r2).prototype = Object.create(s3.prototype), n3.prototype.constructor = n3, Qn(n3, s3);
            var i2 = r2.prototype;
            return i2.componentDidUpdate = function(e3) {
              e3.rootMargin === this.props.rootMargin && e3.root === this.props.root && e3.threshold === this.props.threshold && e3.skip === this.props.skip && e3.trackVisibility === this.props.trackVisibility && e3.delay === this.props.delay || (this.unobserve(), this.observeNode());
            }, i2.componentWillUnmount = function() {
              this.unobserve(), this.node = null;
            }, i2.observeNode = function() {
              if (this.node && !this.props.skip) {
                var e3 = this.props, t4 = e3.threshold, n4 = e3.root, s4 = e3.rootMargin, r3 = e3.trackVisibility, i3 = e3.delay, o2 = e3.fallbackInView;
                this._unobserveCb = Yn(this.node, this.handleChange, { threshold: t4, root: n4, rootMargin: s4, trackVisibility: r3, delay: i3 }, o2);
              }
            }, i2.unobserve = function() {
              this._unobserveCb && (this._unobserveCb(), this._unobserveCb = null);
            }, i2.render = function() {
              if (!Hn(this.props)) {
                var t4 = this.state, n4 = t4.inView, s4 = t4.entry;
                return this.props.children({ inView: n4, entry: s4, ref: this.handleNode });
              }
              var r3 = this.props, i3 = r3.children, o2 = r3.as, a2 = r3.tag, u2 = function(e3, t5) {
                if (null == e3)
                  return {};
                var n5, s5, r4 = {}, i4 = Object.keys(e3);
                for (s5 = 0; s5 < i4.length; s5++)
                  n5 = i4[s5], t5.indexOf(n5) >= 0 || (r4[n5] = e3[n5]);
                return r4;
              }(r3, Zn);
              return e2.createElement(o2 || a2 || "div", Ln({ ref: this.handleNode }, u2), i3);
            }, r2;
          }(e2.Component);
          Jn.displayName = "InView", Jn.defaultProps = { threshold: 0, triggerOnce: false, initialInView: false };
          const Xn = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9], Kn = ({ animateToNumber: n3, fontStyle: s3, configs: r2, includeComma: i2, locale: o2 }) => {
            const { ref: a2, inView: u2 } = function(t3) {
              var n4 = void 0 === t3 ? {} : t3, s4 = n4.threshold, r3 = n4.delay, i3 = n4.trackVisibility, o3 = n4.rootMargin, a3 = n4.root, u3 = n4.triggerOnce, l3 = n4.skip, c3 = n4.initialInView, d3 = n4.fallbackInView, h3 = e2.useRef(), p3 = e2.useState({ inView: !!c3 }), f3 = p3[0], m3 = p3[1], g2 = e2.useCallback(function(e3) {
                void 0 !== h3.current && (h3.current(), h3.current = void 0), l3 || e3 && (h3.current = Yn(e3, function(e4, t4) {
                  m3({ inView: e4, entry: t4 }), t4.isIntersecting && u3 && h3.current && (h3.current(), h3.current = void 0);
                }, { root: a3, rootMargin: o3, threshold: s4, trackVisibility: i3, delay: r3 }, d3));
              }, [Array.isArray(s4) ? s4.toString() : s4, a3, o3, u3, l3, i3, d3, r3]);
              (0, e2.useEffect)(function() {
                h3.current || !f3.entry || u3 || l3 || m3({ inView: !!c3 });
              });
              var y2 = [g2, f3.inView, f3.entry];
              return y2.ref = y2[0], y2.inView = y2[1], y2.entry = y2[2], y2;
            }({ triggerOnce: true }), l2 = t2().useRef(0), c2 = i2 ? Math.abs(n3).toLocaleString(o2 || "en-US") : String(Math.abs(n3)), d2 = Array.from(c2, Number).map((e3, t3) => isNaN(e3) ? c2[t3] : e3), [h2, p2] = t2().useState(0), f2 = t2().useRef(null), m2 = (e3, t3, n4) => {
              return "function" == typeof e3 ? e3(t3, n4) : e3 ? e3[s4 = 0, r3 = e3.length - 1, s4 = Math.ceil(s4), r3 = Math.floor(r3), Math.floor(Math.random() * (r3 - s4 + 1)) + s4] : void 0;
              var s4, r3;
            };
            return t2().useEffect(() => {
              var e3, t3;
              const n4 = null === (e3 = f2.current.getClientRects()) || void 0 === e3 || null === (t3 = e3[0]) || void 0 === t3 ? void 0 : t3.height;
              n4 && p2(n4);
            }, [n3, s3]), t2().createElement(t2().Fragment, null, 0 !== h2 && t2().createElement("div", { ref: a2, style: { display: "flex", flexDirection: "row" }, className: "animated-container" }, u2 && n3 < 0 && t2().createElement("div", { style: s3 }, "-"), u2 && d2.map((e3, n4) => "string" == typeof e3 ? t2().createElement("div", { key: n4, style: { ...s3 } }, e3) : t2().createElement("div", { key: n4, style: { height: h2, overflow: "hidden" } }, t2().createElement(_n, { key: "" + l2.current++, from: { transform: "translateY(0px)" }, to: { transform: `translateY(${h2 * d2[n4] * -1 - 20 * h2})` }, config: m2(r2, e3, n4) }, (e4) => Xn.map((n5, r3) => t2().createElement(Dn.div, { key: r3, style: { ...s3, ...e4 } }, n5)))))), t2().createElement("div", { ref: f2, style: { position: "absolute", top: -9999, ...s3 } }, 0));
          }, es = t2().memo(Kn, (e3, t3) => e3.animateToNumber === t3.animateToNumber && e3.fontStyle === t3.fontStyle && e3.includeComma === t3.includeComma);
        })(), i;
      })();
    });
  }
});
export default require_dist();
//# sourceMappingURL=react-animated-numbers.js.map
